#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include "cilk-lib.cilkh"
#include "cilk.h"
#include "../../shared/util.h"

void EXPORT(datapara) (CilkContext *const ctx, uint i, uint j, ATYPE a[], uint unit);
void EXPORT(rec) (CilkContext *const ctx, ATYPE *a[], uint n);

void usage_abort(void) {
	fprintf(stderr, "Abortingâ€¦\n");
	exit(EXIT_FAILURE);
}

cilk void datapara(uint i, uint j, ATYPE a[], uint unit) {
	if (j-i <= unit) {
		uint k;
		for (k = i; k < j; k++)
			a[k] += a[k-1];
	} else {
		spawn datapara(i, j/2, a, unit);
		spawn datapara(j/2+1, j, a,unit);
		sync;
	}
}

cilk void reduce_rec(ATYPE a[], uint n) {
	if (n > 3) {
		spawn reduce_rec(a + 0, n/2);
		spawn reduce_rec(a + n/2, n - n/2);
		sync;
		a[n-1] += a[n/2-1];
	} else if (n > 1) { // n = 2 or 3. 2: we add up, 3: we add up and leave the odd one in place
		a[1] = a[0] + a[1];
	} else if (n == 1)
		; // nothing todo
}

cilk void halfsum_rec(ATYPE a[], uint lower, uint upper, uint p) {
	uint i;
	for (i = lower-1; i < upper-1; i+=p/2) {
		a[i+p/4] += a[i];
	}
}
cilk void combine_rec(ATYPE a[], uint n, uint p) {
	if (p > 2) {
		spawn halfsum_rec(a, p/2, p, p);
		spawn halfsum_rec(a, p  , n, p);
		sync; // FIXME: nochmal anschauen. kann man sich das nicht sparen?
		spawn combine_rec(a, n, p/2);
	}
}

cilk void rec(ATYPE *arr[], uint n) {
	uint n_n = roundUpPowerOf2(n);
	ATYPE *a_n = realloc(*arr, sizeof(ATYPE) * n_n);
	if (a_n == NULL) {
		fprintf(stderr, "Could not reallocate array!\n");
		return;
	}
	spawn reduce_rec(a_n, n_n);
	sync;
	a_n[n_n - n_n/4 - 1] += a_n[n_n - n_n/2 - 1];
	spawn combine_rec(a_n, n_n, n_n/2);
	*arr = a_n;
}

enum algo {data, task};
int main(int argc, char *argv[]) {
	Cilk_time timestamp; // oh cilk i hate you so much. try narrowing its scope to see why.
	CilkContext* ctx;
	ATYPE *arr;
	ATYPE *cor;
	char opt;
	int option_index;
	uint t = 0;
	uint n = 0;
	enum algo algo = task;
	static const char optstring[] = "n:a:";
	static const struct option long_options[] = {
		{"nproc",		1, NULL, 't'},
		{NULL,			0, NULL, 0},
	};

	while ((opt = getopt_long(argc, argv, optstring, long_options, &option_index)) != EOF) {
		switch (opt) {
		case 't':
			t = atoi(optarg); // TODO: error handling
			break;
		case 'n':
			n = atoi(optarg); // TODO: error handling
			break;
		case 'a':
			if (strcmp("data", optarg) == 0) {
				printf("Using data parallel algorithm\n");
				algo = data;
			} else if (strcmp("task", optarg) == 0) {
				printf("Using task parallel algorithm\n");
				algo = task;
			} else
				fprintf(stderr, "Warning: unknown algorithm %s, using default.\n", optarg);
			break;
		default:
			usage_abort();
			break;
		}
	}

	if (optind < argc) {
		fprintf(stderr, "Warning: Extra parameters found.\n");
	}

	if (t == 0){
		fprintf(stderr, "Number of threads required!\n");
		usage_abort();
	}

	if (n == 0){
		fprintf(stderr, "Legal array size n required!\n");
		usage_abort();
	}

	ctx = Cilk_init(&argc, argv);
	if(ctx == NULL)
		return EXIT_FAILURE;

	arr = malloc(sizeof(ATYPE) * n);
	if (arr == NULL)
		return EXIT_FAILURE;

	arr = fillArr(arr, n);

	cor = malloc(sizeof(ATYPE) * n);
	if (cor == NULL)
		return EXIT_FAILURE;

	prefixSums(arr, n, false, cor);

	timestamp = Cilk_get_wall_time();
	if (algo == data) {
		printf("unit = n/t = %d\n", n/t);
		EXPORT(datapara)(ctx, 0, n, arr, n/t);
	} else
		EXPORT(rec)(ctx, &arr, n);
	timestamp = Cilk_get_wall_time() - timestamp;

	Cilk_terminate (ctx);
	if (n < 100)
		printArrs(cor, arr, n);

	printf("Correct? %s\n", memcmp(cor, arr, sizeof(ATYPE) * n) == 0 ? "yes" : "no");
	printf("%f s elapsed in %d threads.\n", Cilk_wall_time_to_sec(timestamp), t);

	free(cor);
	free(arr);

	return 0;
}
